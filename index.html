<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Parcel Master: Debug Mode</title>
    <!-- OpenCV laden -->
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: monospace; color: white; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* WICHTIG: Video sichtbar machen für Debugging, Canvas liegt darüber */
        video { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 2; pointer-events: none; }
        
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; 
            display: flex; flex-direction: column; justify-content: space-between; pointer-events: none;
        }

        .top-info { background: rgba(0,0,0,0.7); padding: 10px; text-align: center; pointer-events: auto; }
        .log-box { font-size: 0.8rem; color: #0f0; min-height: 20px; }
        .error-box { font-size: 0.8rem; color: #f00; font-weight: bold; }

        .controls { padding: 20px; text-align: center; pointer-events: auto; background: rgba(0,0,0,0.5); }
        button { 
            padding: 15px 30px; font-size: 1.1rem; border-radius: 8px; border: none; 
            background: #007bff; color: white; font-weight: bold; cursor: pointer;
        }
        button:disabled { background: #555; color: #aaa; }
    </style>
</head>
<body>

<div id="container">
    <!-- Playsinline ist wichtig für iOS! -->
    <video id="videoInput" playsinline muted></video>
    <canvas id="canvasOutput"></canvas>
    
    <div id="ui-layer">
        <div class="top-info">
            <div id="status">Lade OpenCV (ca. 8MB)... Bitte warten.</div>
            <div id="error-log" class="error-box"></div>
        </div>
        
        <div class="controls">
            <button id="btn-start" disabled onclick="startCamera()">KAMERA STARTEN</button>
        </div>
    </div>
</div>

<script>
// UI Referenzen
const statusEl = document.getElementById('status');
const errorEl = document.getElementById('error-log');
const btnStart = document.getElementById('btn-start');
const video = document.getElementById('videoInput');
const canvas = document.getElementById('canvasOutput');
const ctx = canvas.getContext('2d');

// Variablen
let stream = null;
let cvReady = false;
let isStreaming = false;

// OpenCV Objekte (werden erst initiiert wenn Video läuft)
let src, dst, contours, hierarchy, poly;

function logError(msg) {
    console.error(msg);
    errorEl.innerText = "FEHLER: " + msg;
}

// 1. Wird aufgerufen, wenn das OpenCV Skript fertig geladen ist
function onOpenCvReady() {
    cvReady = true;
    statusEl.innerText = "OpenCV bereit. Bitte Kamera starten.";
    btnStart.disabled = false;
    btnStart.style.background = "#28a745"; // Grün
}

// 2. Kamera manuell starten (umgeht Autoplay-Blockade)
async function startCamera() {
    statusEl.innerText = "Frage Kamera-Zugriff an...";
    btnStart.style.display = "none"; // Button weg

    try {
        // Constraints für Handy Rückkamera
        const constraints = { 
            video: { 
                facingMode: "environment", 
                width: { ideal: 1280 }, 
                height: { ideal: 720 } 
            },
            audio: false 
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        
        // Warten bis Video wirklich Daten hat
        video.onloadedmetadata = () => {
            video.play().then(() => {
                statusEl.innerText = "Video läuft! Initialisiere CV...";
                initCV();
            }).catch(e => {
                logError("Play blockiert: " + e.message);
            });
        };
    } catch (err) {
        logError("Kamera Zugriff verweigert oder kein HTTPS! " + err.name);
    }
}

function initCV() {
    try {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Speicher reservieren
        src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
        dst = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
        contours = new cv.MatVector();
        hierarchy = new cv.Mat();
        poly = new cv.Mat(); // Polygon Speicher

        isStreaming = true;
        statusEl.innerText = "Suche A4 Blatt...";
        requestAnimationFrame(processVideo);
    } catch(e) {
        logError("CV Init fehlgeschlagen: " + e.message);
    }
}

// Der Loop (ca 30x pro Sekunde)
function processVideo() {
    if (!isStreaming) return;

    try {
        // Videoframe in OpenCV Matrix laden
        let cap = new cv.VideoCapture(video);
        cap.read(src);

        // Bildverarbeitung: Grau -> Blur -> Canny (Kanten)
        cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(dst, dst, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
        cv.Canny(dst, dst, 50, 150); // Thresholds etwas lockerer

        // Konturen finden
        cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let maxArea = 0;
        let foundContour = null;

        // Loop durch alle gefundenen Formen
        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            
            // Filter: Muss groß genug sein (10% des Bildes)
            if (area > (video.videoWidth * video.videoHeight * 0.1)) {
                let peri = cv.arcLength(cnt, true);
                
                // Form vereinfachen
                cv.approxPolyDP(cnt, poly, 0.02 * peri, true);

                // Check: Hat es 4 Ecken?
                if (poly.rows === 4 && cv.isContourConvex(poly)) {
                    if (area > maxArea) {
                        maxArea = area;
                        // Wir müssen die Punkte kopieren, da 'poly' überschrieben wird
                        // In diesem einfachen Demo zeichnen wir direkt
                        drawResult(poly);
                        statusEl.innerText = "Blatt gefunden! (Grün)";
                    }
                }
            }
        }
        
        // Aufräumen (Sehr wichtig in JS!)
        // Wir löschen hier contours nicht komplett, sondern leeren den Vector für den nächsten Frame
        // Hinweis: In Produktionscode müsste man poly.clone() nutzen und manuell löschen.
    } catch (err) {
        // Fehler einmal loggen, dann loop stoppen um Absturz zu verhindern
        logError(err);
        isStreaming = false;
    }

    requestAnimationFrame(processVideo);
}

function drawResult(polyData) {
    // Zeichne grünen Rahmen auf das Canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Erst alles löschen
    
    ctx.beginPath();
    ctx.lineWidth = 5;
    ctx.strokeStyle = "#00ff00";
    
    // polyData enthält die Punkte [x1, y1, x2, y2, ...]
    const pts = polyData.data32S; // Array mit Integer Koordinaten
    ctx.moveTo(pts[0], pts[1]);
    ctx.lineTo(pts[2], pts[3]);
    ctx.lineTo(pts[4], pts[5]);
    ctx.lineTo(pts[6], pts[7]);
    ctx.closePath();
    ctx.stroke();
}
</script>
</body>
</html>