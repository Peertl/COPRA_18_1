<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Parcel Master: OpenCV A4</title>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; z-index: 1; opacity: 0; } /* Video versteckt, wir zeichnen auf Canvas */
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 2; }
        
        #ui { position: absolute; top: 20px; left: 0; width: 100%; z-index: 10; text-align: center; pointer-events: none; }
        .status-box { 
            display: inline-block; padding: 10px 20px; border-radius: 8px; 
            background: rgba(0,0,0,0.7); color: white; font-weight: bold; border: 2px solid #555;
        }
        .loading { color: #ffc107; border-color: #ffc107; }
        .searching { color: #dc3545; border-color: #dc3545; } /* ROT */
        .found { color: #28a745; border-color: #28a745; } /* GRÜN */

        #controls { position: absolute; bottom: 30px; width: 100%; z-index: 10; text-align: center; }
        button { 
            padding: 15px 30px; font-size: 1.2rem; border-radius: 30px; border: none; 
            background: #007bff; color: white; font-weight: bold; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); opacity: 0.5; pointer-events: none; transition: 0.3s;
        }
        button.active { opacity: 1; pointer-events: auto; transform: scale(1.05); }

    </style>
</head>
<body>

<div id="container">
    <video id="videoInput" playsinline muted autoplay></video>
    <canvas id="canvasOutput"></canvas>
    
    <div id="ui">
        <div id="status" class="status-box loading">Lade OpenCV...</div>
    </div>

    <div id="controls">
        <button id="btn-snap">SCANNE BLATT</button>
    </div>
</div>

<script>
let video = document.getElementById("videoInput");
let canvas = document.getElementById("canvasOutput");
let ctx = canvas.getContext("2d");
let statusBox = document.getElementById("status");
let btnSnap = document.getElementById("btn-snap");

let stream = null;
let cvReady = false;
let isRunning = false;
let detectedContour = null; // Speichert das gefundene Viereck

// OpenCV Variablen (global um GC zu schonen)
let src, dst, gray, cap, contours, hierarchy, poly;

function onOpenCvReady() {
    cvReady = true;
    statusBox.innerText = "Kamera starten...";
    statusBox.className = "status-box";
    startCamera();
}

async function startCamera() {
    try {
        stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } 
        });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
            video.play();
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            initOpenCV();
        };
    } catch (err) {
        statusBox.innerText = "Kamera Fehler!";
        console.error(err);
    }
}

function initOpenCV() {
    // Matrizen einmalig initialisieren
    src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    dst = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1); // Graustufen
    gray = new cv.Mat();
    contours = new cv.MatVector();
    hierarchy = new cv.Mat();
    poly = new cv.Mat();
    
    // Video Capture Helper
    cap = new cv.VideoCapture(video);
    
    isRunning = true;
    statusBox.innerText = "Suche Blatt...";
    statusBox.className = "status-box searching";
    
    requestAnimationFrame(processVideo);
}

function processVideo() {
    if (!isRunning) return;

    try {
        // 1. Bild vom Video holen
        cap.read(src);
        
        // 2. Bildverarbeitung Pipeline
        cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0); // Grau
        cv.GaussianBlur(dst, dst, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT); // Weichzeichnen (Rauschen weg)
        cv.Canny(dst, dst, 75, 200, 3, false); // Kanten finden (Thresholds 75/200 anpassbar)
        
        // 3. Konturen finden
        // RETR_EXTERNAL = Nur äußere Konturen, keine Löcher im Papier
        cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let maxArea = 0;
        let bestContour = null;
        let found = false;

        // 4. Durch alle Konturen loopen
        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            
            // Nur große Flächen betrachten (> 5% des Bildschirms grob geschätzt)
            if (area > (video.videoWidth * video.videoHeight * 0.05)) {
                
                // Polygon Approximation (Wieviele Ecken hat das Ding?)
                let peri = cv.arcLength(cnt, true);
                cv.approxPolyDP(cnt, poly, 0.02 * peri, true);

                // Wenn es 4 Ecken sind & konvex (kein Pacman)
                if (poly.rows === 4 && cv.isContourConvex(poly)) {
                    if (area > maxArea) {
                        maxArea = area;
                        bestContour = poly.clone(); // Kopie speichern
                        found = true;
                    }
                }
            }
        }

        // 5. Zeichnen
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height); // Video Clean zeichnen
        
        if (found && bestContour) {
            // Gefundenes Blatt grün umranden
            statusBox.innerText = "Blatt erkannt!";
            statusBox.className = "status-box found";
            btnSnap.className = "active";
            
            // Zeichne Linie um das Blatt (Manuell, da cv.drawContours kompliziert auf Canvas ist)
            drawQuad(bestContour);
            
            detectedContour = bestContour; // Für späteren Snapshot speichern
        } else {
            statusBox.innerText = "Suche Blatt...";
            statusBox.className = "status-box searching";
            btnSnap.className = "";
        }

    } catch (err) {
        console.error(err);
    }

    // Speicher aufräumen (WICHTIG in JS!)
    // Wir löschen contours nicht komplett, sondern leeren den Vektor, 
    // aber poly.clone() muss manuell gelöscht werden, wenn wir es nicht mehr brauchen.
    if(contours && !contours.isDeleted()) contours.delete();
    contours = new cv.MatVector(); 

    requestAnimationFrame(processVideo);
}

// Hilfsfunktion zum Zeichnen des grünen Rahmens
function drawQuad(polyMat) {
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#00ff00";
    ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
    
    ctx.beginPath();
    // polyMat daten lesen: Es sind 4 Punkte (int32), jeder hat x,y
    const data = polyMat.data32S; 
    ctx.moveTo(data[0], data[1]);
    ctx.lineTo(data[2], data[3]);
    ctx.lineTo(data[4], data[5]);
    ctx.lineTo(data[6], data[7]);
    ctx.closePath();
    ctx.stroke();
    ctx.fill();
    
    // Cleanup der Clone-Kopie sofort nach dem Zeichnen, um Memory Leaks zu vermeiden? 
    // Nein, wir brauchen 'detectedContour' vielleicht beim Klick.
    // Aber 'bestContour' im Loop oben erzeugt jedes Frame neuen Speicher -> Leak Gefahr!
    // In diesem einfachen Beispiel lassen wir den GC arbeiten, aber sauberer wäre manuelles delete.
    polyMat.delete(); 
}

// Button Klick
btnSnap.addEventListener("click", () => {
    if (!detectedContour) return;
    isRunning = false; // Video Stop
    statusBox.innerText = "Gescannt! Berechne Pixel/CM...";
    
    // HIER KANNST DU JETZT RECHNEN
    // Du hast die 4 Ecken in 'detectedContour'
    // A4 ist 21.0 x 29.7 cm
    // Berechne Distanz der Kanten in Pixeln und vergleiche.
    
    alert("Blatt erfolgreich erfasst! Jetzt kann das Paket kommen.");
});

</script>
</body>
</html>